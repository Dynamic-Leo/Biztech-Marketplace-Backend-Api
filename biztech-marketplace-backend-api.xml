This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: *.svg
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
app.js
package.json
src/api/admin.routes.js
src/api/auth.routes.js
src/api/lead.routes.js
src/api/listing.routes.js
src/api/payment.routes.js
src/api/valuation.routes.js
src/config/database.js
src/controllers/admin.controller.js
src/controllers/auth.controller.js
src/controllers/lead.controller.js
src/controllers/listing.controller.js
src/controllers/payment.controller.js
src/controllers/valuation.controller.js
src/middleware/auth.middleware.js
src/models/index.js
src/models/Lead.js
src/models/Listing.js
src/models/Subscription.js
src/models/User.js
src/models/Valuation.js
src/services/cron.service.js
src/services/email.service.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
node_modules
.env
env
</file>

<file path="app.js">
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const rateLimit = require('express-rate-limit');
const hpp = require('hpp');

const db = require('./src/models');
const initCronJobs = require('./src/services/cron.service');

const app = express();

// 1. Security Headers
app.use(helmet());

// 2. CORS Configuration (Updated for Auth Integration)
// We allow the specific frontend origin to send credentials (cookies/headers)
const corsOptions = {
  origin: ['http://localhost:5173', process.env.CLIENT_URL], // Add production URL in .env
  credentials: true, 
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
};

app.use(cors(corsOptions));

// 3. Rate Limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, 
  max: 100, 
  message: 'Too many requests from this IP.'
});
app.use('/api', limiter);

// 4. Prevent Parameter Pollution
app.use(hpp());

app.use(express.json());
app.use(morgan(process.env.NODE_ENV === 'production' ? 'combined' : 'dev'));

// Routes
app.use('/api/v1/auth', require('./src/api/auth.routes'));
app.use('/api/v1/admin', require('./src/api/admin.routes'));
app.use('/api/v1/listings', require('./src/api/listing.routes'));
app.use('/api/v1', require('./src/api/lead.routes'));
app.use('/api/v1/valuation', require('./src/api/valuation.routes'));
app.use('/api/v1/payments', require('./src/api/payment.routes'));

// Specific Controller Routes
const leadController = require('./src/controllers/lead.controller');
const { protect, authorize } = require('./src/middleware/auth.middleware');
app.post('/api/v1/leads', protect, authorize('buyer'), leadController.createLead);
app.get('/api/v1/agent/leads', protect, authorize('agent'), leadController.getAgentLeads);

// Sync DB & Start
db.sequelize.sync({ alter: true }).then(() => {
    console.log("‚úÖ Database Synced");
    initCronJobs();
    const PORT = process.env.PORT || 3000;
    app.listen(PORT, () => console.log(`üöÄ Server running on port ${PORT}`));
}).catch((err) => {
    console.error("‚ùå DB Error:", err.message);
});
</file>

<file path="package.json">
{
  "name": "biztech-bizmarketplace-backend",
  "version": "1.0.0",
  "main": "app.js",
  "scripts": {
    "dev": "nodemon app.js",
    "start": "node app.js"
  },
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "express-rate-limit": "^8.2.1",
    "helmet": "^7.1.0",
    "hpp": "^0.2.3",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.0",
    "mysql2": "^3.6.5",
    "node-cron": "^4.2.1",
    "nodemailer": "^7.0.11",
    "sequelize": "^6.35.1"
  },
  "devDependencies": {
    "nodemon": "^3.0.2"
  }
}
</file>

<file path="src/api/auth.routes.js">
const express = require('express');
const router = express.Router();
const controller = require('../controllers/auth.controller');

router.post('/register', controller.register);
router.post('/verify-email', controller.verifyEmail); // New Route
router.post('/login', controller.login);

module.exports = router;
</file>

<file path="src/api/lead.routes.js">
const express = require('express');
const router = express.Router();
const controller = require('../controllers/lead.controller');
const { protect, authorize } = require('../middleware/auth.middleware');

// Buyer creates lead
router.post('/', protect, authorize('buyer'), controller.createLead);

// Agent manages leads
router.get('/agent/leads', protect, authorize('agent'), controller.getAgentLeads); // Note: path modified in main app router to /api/v1/agent/leads
router.put('/agent/leads/:id', protect, authorize('agent'), controller.updateLeadStatus);

module.exports = router;
</file>

<file path="src/api/payment.routes.js">
const express = require('express');
const router = express.Router();
const controller = require('../controllers/payment.controller');
const { protect, authorize } = require('../middleware/auth.middleware');

// Debugging check (will print to console if undefined)
if (!controller.createSubscription) {
    console.error("‚ùå Error: controller.createSubscription is undefined in payment.routes.js");
}
if (!protect) {
    console.error("‚ùå Error: 'protect' middleware is undefined in payment.routes.js");
}

router.post('/subscribe', protect, authorize('seller'), controller.createSubscription);

module.exports = router;
</file>

<file path="src/api/valuation.routes.js">
const express = require('express');
const router = express.Router();
const controller = require('../controllers/valuation.controller');

router.post('/', controller.requestValuation);

module.exports = router;
</file>

<file path="src/config/database.js">
require('dotenv').config();

module.exports = {
  development: {
    username: process.env.DB_USER,
    password: process.env.DB_PASS,
    database: process.env.DB_NAME,
    host: process.env.DB_HOST,
    dialect: process.env.DB_DIALECT,
    logging: false
  },
  production: {
    username: process.env.DB_USER,
    password: process.env.DB_PASS,
    database: process.env.DB_NAME,
    host: process.env.DB_HOST,
    dialect: process.env.DB_DIALECT,
    logging: false
  }
};
</file>

<file path="src/controllers/auth.controller.js">
const db = require('../models');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { sendEmail } = require('../services/email.service');
const { Op } = require('sequelize');
const User = db.User;

const generateToken = (id) => {
    return jwt.sign({ id }, process.env.JWT_SECRET, { expiresIn: '30d' });
};

const generateOTP = () => {
    return Math.floor(100000 + Math.random() * 900000).toString(); // 6 digit OTP
};

exports.register = async (req, res) => {
    try {
        const { name, email, password, role, agreed_commission, financial_means, mobile } = req.body;

        // Validations
        if (role === 'seller' && agreed_commission !== true) {
            return res.status(400).json({ message: "Sellers must agree to the 1% commission fee." });
        }

        const userExists = await User.findOne({ where: { email } });
        if (userExists) return res.status(400).json({ message: "User already exists" });

        // Hash Password
        const salt = await bcrypt.genSalt(10);
        const hashedPassword = await bcrypt.hash(password, salt);

        // Generate OTP (Expires in 10 minutes)
        const otp = generateOTP();
        const otpExpires = new Date(Date.now() + 10 * 60 * 1000);

        // Create User (Not verified yet)
        await User.create({
            name, 
            email, 
            password: hashedPassword, 
            role, 
            mobile,
            agreed_commission, 
            financial_means,
            otp: otp,
            otp_expires_at: otpExpires,
            is_verified: false,
            account_status: 'pending' // Everyone starts pending until email verified
        });

        // Send OTP Email
        await sendEmail(email, "Verify Your Account", `Your OTP is: ${otp}. It expires in 10 minutes.`);

        res.status(201).json({
            success: true,
            message: "Registration successful. Please check your email for the OTP.",
            email: email
        });

    } catch (error) {
        console.error(error);
        res.status(500).json({ message: error.message });
    }
};

exports.verifyEmail = async (req, res) => {
    try {
        const { email, otp } = req.body;

        const user = await User.findOne({ where: { email } });

        if (!user) {
            return res.status(404).json({ message: "User not found" });
        }

        if (user.is_verified) {
            return res.status(400).json({ message: "User is already verified" });
        }

        // Check OTP and Expiry
        if (user.otp !== otp) {
            return res.status(400).json({ message: "Invalid OTP" });
        }

        if (new Date() > user.otp_expires_at) {
            return res.status(400).json({ message: "OTP has expired" });
        }

        // Update User Status
        let responseData = {};
        
        if (user.role === 'buyer') {
            // Buyers are automatically activated after email verification
            await user.update({
                is_verified: true,
                account_status: 'active',
                otp: null,
                otp_expires_at: null
            });

            // Log them in immediately
            const token = generateToken(user.id);
            responseData = {
                success: true,
                message: "Email verified and logged in successfully.",
                token,
                user: { id: user.id, name: user.name, role: user.role, status: 'active' }
            };

        } else if (user.role === 'seller') {
            // Sellers verified email, but still need Admin approval
            await user.update({
                is_verified: true,
                account_status: 'pending', // Remains pending for Admin
                otp: null,
                otp_expires_at: null
            });

            responseData = {
                success: true,
                message: "Email verified. Your account is pending Admin approval.",
                requireApproval: true
            };
        } else {
            // Agent/Admin flow (if applicable)
             await user.update({
                is_verified: true,
                account_status: 'pending',
                otp: null,
                otp_expires_at: null
            });
             responseData = { success: true, message: "Verified." };
        }

        res.status(200).json(responseData);

    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

exports.login = async (req, res) => {
    try {
        const { email, password } = req.body;
        const user = await User.findOne({ where: { email } });

        if (!user || !(await bcrypt.compare(password, user.password))) {
            return res.status(401).json({ message: "Invalid credentials" });
        }

        // Check if Email Verified
        if (!user.is_verified) {
            return res.status(403).json({ message: "Please verify your email address first." });
        }

        // Check Account Status (For Sellers waiting for admin)
        if (user.account_status === 'pending') {
            return res.status(403).json({ message: "Your account is pending Admin approval." });
        }

        if (user.account_status === 'rejected') {
            return res.status(403).json({ message: "Your account has been rejected. Contact support." });
        }

        res.json({
            success: true,
            token: generateToken(user.id),
            user: { id: user.id, name: user.name, role: user.role }
        });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};
</file>

<file path="src/controllers/lead.controller.js">
const db = require('../models');
const Lead = db.Lead;
const Listing = db.Listing;
const User = db.User;

exports.createLead = async (req, res) => {
    try {
        const { listingId, message } = req.body;
        
        const listing = await Listing.findByPk(listingId);
        if (!listing) return res.status(404).json({ message: "Listing not found" });

        const lead = await Lead.create({
            listingId,
            buyerId: req.user.id,
            message
        });

        res.status(201).json({ success: true, data: lead });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

exports.getAgentLeads = async (req, res) => {
    try {
        // Find leads for listings assigned to this agent
        const leads = await Lead.findAll({
            include: [
                { 
                    model: Listing, 
                    as: 'Listing', 
                    where: { assignedAgentId: req.user.id },
                    attributes: ['title', 'id']
                },
                {
                    model: User,
                    as: 'Buyer',
                    attributes: ['name', 'email', 'financial_means']
                }
            ]
        });

        res.status(200).json({ success: true, count: leads.length, data: leads });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

exports.updateLeadStatus = async (req, res) => {
    try {
        const lead = await Lead.findByPk(req.params.id, {
            include: [{ model: Listing, as: 'Listing' }]
        });
        
        if (!lead) return res.status(404).json({ message: "Lead not found" });

        // Authorization check: Only assigned agent
        if (lead.Listing.assignedAgentId !== req.user.id) {
            return res.status(403).json({ message: "Not authorized" });
        }

        await lead.update({ status: req.body.status });
        res.status(200).json({ success: true, data: lead });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};
</file>

<file path="src/controllers/payment.controller.js">
const db = require('../models');
const Subscription = db.Subscription;
const Listing = db.Listing;

// @desc    Simulate Payment for Premium Listing
// @route   POST /api/v1/payments/subscribe
exports.createSubscription = async (req, res) => {
    try {
        const { listingId, amount } = req.body; 

        // Check if listing exists
        const listing = await Listing.findByPk(listingId);
        if (!listing) {
            return res.status(404).json({ message: "Listing not found" });
        }

        // 1. Create Subscription Record
        // (Ensure Subscription model exists in src/models/Subscription.js)
        const subscription = await Subscription.create({
            userId: req.user.id,
            listingId: listing.id,
            amount: amount,
            payment_status: 'paid', // Mocking successful payment
            transaction_id: `tx_${Date.now()}`,
            start_date: new Date(),
            end_date: new Date(new Date().setDate(new Date().getDate() + 90)) // +90 Days
        });

        // 2. Update Listing to Premium & Active
        await listing.update({
            tier: 'premium',
            status: 'active',
            expiryDate: subscription.end_date
        });

        res.status(201).json({ 
            success: true, 
            message: "Subscription successful. Listing upgraded to Premium.",
            data: subscription 
        });

    } catch (error) {
        console.error("Payment Error:", error);
        res.status(500).json({ message: error.message });
    }
};
</file>

<file path="src/controllers/valuation.controller.js">
const db = require('../models');
const Valuation = db.Valuation;

exports.requestValuation = async (req, res) => {
    try {
        const { contactName, contactEmail, phone, businessDetails } = req.body;
        
        // Save to Database
        const valuation = await Valuation.create({
            contact_name: contactName || "Anonymous", // Handle optional fields
            contact_email: contactEmail,
            phone: phone,
            business_details: businessDetails
        });

        res.status(201).json({ 
            success: true, 
            message: "Valuation request saved successfully.",
            data: valuation
        });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};
</file>

<file path="src/middleware/auth.middleware.js">
const jwt = require('jsonwebtoken');
const db = require('../models');
const User = db.User;

exports.protect = async (req, res, next) => {
    let token;
    if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
        try {
            token = req.headers.authorization.split(' ')[1];
            const decoded = jwt.verify(token, process.env.JWT_SECRET);
            req.user = await User.findByPk(decoded.id);
            if(!req.user) throw new Error("User not found");
            next();
        } catch (error) {
            res.status(401).json({ message: "Not authorized, token failed" });
        }
    } else {
        res.status(401).json({ message: "Not authorized, no token" });
    }
};

exports.authorize = (...roles) => {
    return (req, res, next) => {
        if (!req.user) return res.status(401).json({ message: "User not authenticated" });
        if (!roles.includes(req.user.role)) {
            return res.status(403).json({ message: `Role ${req.user.role} is not authorized` });
        }
        next();
    };
};
</file>

<file path="src/models/index.js">
const Sequelize = require('sequelize');
const config = require('../config/database')[process.env.NODE_ENV || 'development'];

const sequelize = new Sequelize(config.database, config.username, config.password, config);

const db = {};
db.Sequelize = Sequelize;
db.sequelize = sequelize;

// Import Models
db.User = require('./User')(sequelize, Sequelize);
db.Listing = require('./Listing')(sequelize, Sequelize);
db.Lead = require('./Lead')(sequelize, Sequelize);
// --- NEW MODELS ---
db.Subscription = require('./Subscription')(sequelize, Sequelize);
db.Valuation = require('./Valuation')(sequelize, Sequelize);

// Initialize associations
Object.keys(db).forEach(modelName => {
    if (db[modelName].associate) {
        db[modelName].associate(db);
    }
});

module.exports = db;
</file>

<file path="src/models/Lead.js">
module.exports = (sequelize, DataTypes) => {
    const Lead = sequelize.define("Lead", {
        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
        message: { type: DataTypes.TEXT, allowNull: false },
        status: { 
            type: DataTypes.ENUM('new', 'contacted', 'closed'), 
            defaultValue: 'new' 
        }
    });

    Lead.associate = (models) => {
        Lead.belongsTo(models.Listing, { foreignKey: 'listingId', as: 'Listing' });
        Lead.belongsTo(models.User, { foreignKey: 'buyerId', as: 'Buyer' });
    };

    return Lead;
};
</file>

<file path="src/models/Subscription.js">
module.exports = (sequelize, DataTypes) => {
    const Subscription = sequelize.define("Subscription", {
        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
        amount: { type: DataTypes.DECIMAL(10, 2), allowNull: false },
        currency: { type: DataTypes.STRING, defaultValue: 'AED' },
        payment_status: { 
            type: DataTypes.ENUM('pending', 'paid', 'failed'), 
            defaultValue: 'pending' 
        },
        transaction_id: { type: DataTypes.STRING }, // From Stripe/Gateway
        start_date: { type: DataTypes.DATE },
        end_date: { type: DataTypes.DATE }
    });

    Subscription.associate = (models) => {
        Subscription.belongsTo(models.User, { foreignKey: 'userId', as: 'User' });
        Subscription.belongsTo(models.Listing, { foreignKey: 'listingId', as: 'Listing' });
    };

    return Subscription;
};
</file>

<file path="src/models/User.js">
module.exports = (sequelize, DataTypes) => {
    const User = sequelize.define("User", {
        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
        name: { type: DataTypes.STRING, allowNull: false },
        email: { type: DataTypes.STRING, allowNull: false, unique: true, validate: { isEmail: true } },
        password: { type: DataTypes.STRING, allowNull: false },
        role: { 
            type: DataTypes.ENUM('admin', 'agent', 'seller', 'buyer'), 
            defaultValue: 'buyer' 
        },
        mobile: { type: DataTypes.STRING },
        
        // --- NEW FIELDS FOR OTP & APPROVAL ---
        otp: { type: DataTypes.STRING, allowNull: true },
        otp_expires_at: { type: DataTypes.DATE, allowNull: true },
        is_verified: { type: DataTypes.BOOLEAN, defaultValue: false },
        account_status: { 
            type: DataTypes.ENUM('pending', 'active', 'rejected'), 
            defaultValue: 'pending' 
        },

        // Buyer Specific
        financial_means: { 
            type: DataTypes.ENUM('<100k', '100k-1M', '>1M'),
            allowNull: true
        },
        // Seller Specific
        agreed_commission: { 
            type: DataTypes.BOOLEAN, 
            defaultValue: false 
        }
    });

    User.associate = (models) => {
        User.hasMany(models.Listing, { foreignKey: 'sellerId', as: 'Listings' });
        User.hasMany(models.Listing, { foreignKey: 'assignedAgentId', as: 'AssignedListings' });
        User.hasMany(models.Lead, { foreignKey: 'buyerId', as: 'Enquiries' });
    };

    return User;
};
</file>

<file path="src/models/Valuation.js">
module.exports = (sequelize, DataTypes) => {
    const Valuation = sequelize.define("Valuation", {
        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
        contact_name: { type: DataTypes.STRING, allowNull: false },
        contact_email: { type: DataTypes.STRING, allowNull: false, validate: { isEmail: true } },
        phone: { type: DataTypes.STRING },
        business_details: { type: DataTypes.TEXT, allowNull: false },
        status: { 
            type: DataTypes.ENUM('new', 'reviewed', 'contacted'), 
            defaultValue: 'new' 
        }
    });

    return Valuation;
};
</file>

<file path="src/services/cron.service.js">
const cron = require('node-cron');
const { Op } = require('sequelize');
const db = require('../models');
const Listing = db.Listing;
const { sendEmail } = require('./email.service');

const initCronJobs = () => {
    // Run every day at midnight: '0 0 * * *'
    cron.schedule('0 0 * * *', async () => {
        console.log('--- Running Daily Listing Expiry Check ---');
        try {
            const today = new Date();
            
            // Find active premium listings that have expired
            const expiredListings = await Listing.findAll({
                where: {
                    status: 'active',
                    expiryDate: { [Op.lt]: today }, // Less than today
                    tier: 'premium'
                },
                include: ['Seller']
            });

            for (const listing of expiredListings) {
                // Update status
                listing.status = 'expired';
                await listing.save();

                // Notify Seller
                if (listing.Seller && listing.Seller.email) {
                    await sendEmail(
                        listing.Seller.email, 
                        "Your Listing Has Expired", 
                        `Your listing "${listing.title}" has expired. Please renew your subscription.`
                    );
                }
            }
            console.log(`Processed ${expiredListings.length} expired listings.`);
        } catch (error) {
            console.error('Cron Job Error:', error);
        }
    });
};

module.exports = initCronJobs;
</file>

<file path="src/services/email.service.js">
const nodemailer = require('nodemailer');

// Create the transporter using credentials from .env
const transporter = nodemailer.createTransport({
    host: process.env.SMTP_HOST,
    port: process.env.SMTP_PORT,
    secure: process.env.SMTP_PORT == 465, // true for 465, false for other ports (587)
    auth: {
        user: process.env.SMTP_USER,
        pass: process.env.SMTP_PASS,
    },
});

exports.sendEmail = async (to, subject, text) => {
    try {
        const mailOptions = {
            from: `"${process.env.FROM_NAME || 'BizTech Support'}" <${process.env.FROM_EMAIL}>`,
            to: to,
            subject: subject,
            text: text, // Plain text body
            html: `<div style="font-family: Arial, sans-serif; padding: 20px; color: #333;">
                    <h2 style="color: #0D1B2A;">BizTech Verification</h2>
                    <p style="font-size: 16px;">${text}</p>
                    <hr style="border: 1px solid #eee; margin: 20px 0;" />
                    <small style="color: #999;">If you didn't request this code, please ignore this email.</small>
                   </div>` // HTML body
        };

        const info = await transporter.sendMail(mailOptions);
        console.log(`‚úÖ Email sent: ${info.messageId}`);
        return true;
    } catch (error) {
        console.error("‚ùå Error sending email:", error);
        return false;
    }
};
</file>

<file path="src/api/admin.routes.js">
const express = require('express');
const router = express.Router();
const controller = require('../controllers/admin.controller');
const { protect, authorize } = require('../middleware/auth.middleware');

// Apply protection to all admin routes
router.use(protect);
router.use(authorize('admin'));

// Stats & User Management
router.get('/stats', controller.getDashboardStats);
router.get('/users', controller.getUsers);
router.put('/users/:id/status', controller.updateUserStatus);

// Listing & Agent Management
router.post('/create-agent', controller.createAgent);
router.get('/pending-listings', controller.getPendingListings);
router.post('/assign-agent', controller.assignAgent);

module.exports = router;
</file>

<file path="src/api/listing.routes.js">
const express = require('express');
const router = express.Router();
const controller = require('../controllers/listing.controller');
const { protect, authorize } = require('../middleware/auth.middleware');

// 1. Specific routes MUST come before generic /:id routes
router.get('/my-listings', protect, authorize('seller'), controller.getSellerListings);

// 2. Creation and Public routes
router.post('/', protect, authorize('seller'), controller.createListing);
router.get('/', controller.getListings); 

// 3. Generic ID route (moved to bottom)
router.get('/:id', async (req, res, next) => {
    if (req.headers.authorization) { 
        await protect(req, res, next); 
    } else { 
        next(); 
    }
}, controller.getListingById);

router.post('/:id/financing', protect, authorize('seller'), controller.requestFinancing);

module.exports = router;
</file>

<file path="src/controllers/admin.controller.js">
const db = require('../models');
const bcrypt = require('bcryptjs');
const User = db.User;
const Listing = db.Listing;

// @desc    Get Admin Dashboard Stats (Dynamic Counts)
exports.getDashboardStats = async (req, res) => {
    try {
        const totalUsers = await User.count();
        const pendingApprovals = await User.count({ 
            where: { account_status: 'pending', role: 'seller' } 
        });
        const activeListings = await Listing.count({ 
            where: { status: 'active' } 
        });
        const totalAgents = await User.count({ 
            where: { role: 'agent' } 
        });
        
        // Dynamic Revenue Calculation: AED 499 for every active Premium listing
        const premiumCount = await Listing.count({ 
            where: { tier: 'premium', status: 'active' } 
        });
        const monthlyRevenue = premiumCount * 499;

        res.status(200).json({
            success: true,
            data: {
                totalUsers,
                pendingApprovals,
                activeListings,
                totalAgents,
                monthlyRevenue
            }
        });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

// @desc    Get All Users with Filters
exports.getUsers = async (req, res) => {
    try {
        const { role, status } = req.query;
        let whereClause = {};
        if (role) whereClause.role = role;
        if (status) whereClause.account_status = status;

        const users = await User.findAll({ 
            where: whereClause,
            attributes: { exclude: ['password', 'otp'] },
            order: [['createdAt', 'DESC']]
        });
        res.status(200).json({ success: true, data: users });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

// @desc    Approve/Reject Seller Account
exports.updateUserStatus = async (req, res) => {
    try {
        const { id } = req.params;
        const { status } = req.body; // 'active' or 'rejected'

        const user = await User.findByPk(id);
        if (!user) return res.status(404).json({ message: "User not found" });

        await user.update({ account_status: status });
        res.status(200).json({ success: true, message: `User is now ${status}` });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

// @desc    Get listings that need an agent assigned
exports.getPendingListings = async (req, res) => {
    try {
        const listings = await Listing.findAll({
            where: { status: 'pending' },
            include: [{ model: User, as: 'Seller', attributes: ['name', 'email'] }]
        });
        res.status(200).json({ success: true, count: listings.length, data: listings });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

// @desc    Assign Agent and Activate Ad
exports.assignAgent = async (req, res) => {
    try {
        const { listingId, agentId } = req.body;
        const listing = await Listing.findByPk(listingId);
        if(!listing) return res.status(404).json({ message: "Listing not found" });

        await listing.update({
            assignedAgentId: agentId,
            status: 'active' 
        });

        res.status(200).json({ success: true, message: "Agent assigned and Listing activated" });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

// @desc    Create Internal Agent Account
exports.createAgent = async (req, res) => {
    try {
        const { name, email, password } = req.body;
        const hashedPassword = await bcrypt.hash(password, 10);
        await User.create({ 
            name, email, password: hashedPassword, role: 'agent', is_verified: true, account_status: 'active' 
        });
        res.status(201).json({ success: true, message: "Agent created" });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};
</file>

<file path="src/controllers/listing.controller.js">
const db = require('../models');
const { Op } = require('sequelize');
const Listing = db.Listing;
const User = db.User;
const Lead = db.Lead;

// @desc    Get all listings belonging to the logged-in seller
exports.getSellerListings = async (req, res) => {
    try {
        const listings = await Listing.findAll({
            where: { sellerId: req.user.id },
            include: [
                {
                    model: Lead,
                    as: 'Leads',
                    attributes: ['id']
                }
            ],
            order: [['createdAt', 'DESC']]
        });

        res.status(200).json({ 
            success: true, 
            data: listings 
        });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

exports.createListing = async (req, res) => {
    try {
        const { 
            title, industry, price, net_profit, turnover, region, 
            legal_business_name, full_address, owner_name, tier 
        } = req.body;

        const listing = await Listing.create({
            sellerId: req.user.id,
            title, 
            industry, 
            price, 
            net_profit, 
            turnover, 
            region,
            legal_business_name, 
            full_address, 
            owner_name,
            tier: tier || 'basic',
            status: 'pending'
        });

        res.status(201).json({ success: true, data: listing });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

exports.getListings = async (req, res) => {
    try {
        const { location, priceMax, industry, searchTerm } = req.query;
        let whereClause = { status: 'active' };

        if (location) whereClause.region = { [Op.like]: `%${location}%` };
        if (industry) whereClause.industry = { [Op.like]: `%${industry}%` };
        if (priceMax) whereClause.price = { [Op.lte]: priceMax };
        if (searchTerm) whereClause.title = { [Op.like]: `%${searchTerm}%` };

        const listings = await Listing.findAll({
            where: whereClause,
            order: [
                [db.sequelize.literal("FIELD(tier, 'premium', 'basic')"), 'ASC'],
                ['createdAt', 'DESC']
            ],
            attributes: { exclude: ['legal_business_name', 'full_address', 'owner_name'] }
        });

        res.status(200).json({ success: true, count: listings.length, data: listings });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

exports.getListingById = async (req, res) => {
    try {
        const listing = await Listing.findByPk(req.params.id);
        if (!listing) return res.status(404).json({ message: "Listing not found" });

        let isAuthorized = false;
        
        if (req.user) {
            if (req.user.role === 'admin') isAuthorized = true;
            if (req.user.role === 'seller' && listing.sellerId === req.user.id) isAuthorized = true;
            if (req.user.role === 'agent' && listing.assignedAgentId === req.user.id) isAuthorized = true;
        }

        let response = listing.toJSON();

        if (!isAuthorized) {
            delete response.legal_business_name;
            delete response.full_address;
            delete response.owner_name;
            await listing.increment('views');
        }

        res.status(200).json({ success: true, data: response });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

exports.requestFinancing = async (req, res) => {
    try {
        const listing = await Listing.findByPk(req.params.id);
        if(!listing) return res.status(404).json({ message: "Listing not found" });

        if (listing.sellerId !== req.user.id) return res.status(403).json({ message: "Unauthorized" });
        if (listing.tier !== 'premium') return res.status(400).json({ message: "Only Premium sellers can request financing support" });

        await listing.update({ financing_requested: true });
        res.status(200).json({ success: true, message: "Financing request sent to agent" });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};
</file>

<file path="src/models/Listing.js">
module.exports = (sequelize, DataTypes) => {
    const Listing = sequelize.define("Listing", {
        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
        // Public Data
        title: { type: DataTypes.STRING, allowNull: false },
        industry: { type: DataTypes.STRING, allowNull: false },
        region: { type: DataTypes.STRING, allowNull: false },
        price: { type: DataTypes.DECIMAL(15, 2), allowNull: false },
        net_profit: { type: DataTypes.DECIMAL(15, 2) },
        turnover: { type: DataTypes.DECIMAL(15, 2) },
        
        // Private Data
        legal_business_name: { type: DataTypes.STRING },
        full_address: { type: DataTypes.TEXT },
        owner_name: { type: DataTypes.STRING },

        // Tiering & SRS Deliverables
        tier: { 
            type: DataTypes.ENUM('basic', 'premium'), 
            defaultValue: 'basic' 
        },
        // NEW fields based on SRS screenshot:
        sale_pack_ready: { type: DataTypes.BOOLEAN, defaultValue: false }, // Business assessments
        financial_analysis_ready: { type: DataTypes.BOOLEAN, defaultValue: false }, // Analysis & projections
        legal_attestation_ready: { type: DataTypes.BOOLEAN, defaultValue: false }, // Final arrangements
        transfer_arrangements_ready: { type: DataTypes.BOOLEAN, defaultValue: false },

        status: { 
            type: DataTypes.ENUM('pending', 'active', 'sold', 'expired'), 
            defaultValue: 'pending' 
        },
        expiryDate: { type: DataTypes.DATE },
        views: { type: DataTypes.INTEGER, defaultValue: 0 },
        financing_requested: { type: DataTypes.BOOLEAN, defaultValue: false }
    });

    Listing.associate = (models) => {
        Listing.belongsTo(models.User, { foreignKey: 'sellerId', as: 'Seller' });
        Listing.belongsTo(models.User, { foreignKey: 'assignedAgentId', as: 'Agent' });
        Listing.hasMany(models.Lead, { foreignKey: 'listingId', as: 'Leads' });
    };

    return Listing;
};
</file>

</files>
