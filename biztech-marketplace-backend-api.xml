This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: *.svg
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
app.js
package.json
src/api/admin.routes.js
src/api/auth.routes.js
src/api/lead.routes.js
src/api/listing.routes.js
src/api/payment.routes.js
src/api/valuation.routes.js
src/config/database.js
src/controllers/admin.controller.js
src/controllers/auth.controller.js
src/controllers/lead.controller.js
src/controllers/listing.controller.js
src/controllers/payment.controller.js
src/controllers/valuation.controller.js
src/middleware/auth.middleware.js
src/models/index.js
src/models/Lead.js
src/models/Listing.js
src/models/Subscription.js
src/models/User.js
src/models/Valuation.js
src/services/cron.service.js
src/services/email.service.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
node_modules
</file>

<file path="app.js">
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const db = require('./src/models');
const initCronJobs = require('./src/services/cron.service'); // Import Cron

const app = express();

app.use(helmet());
app.use(cors());
app.use(express.json());
app.use(morgan('dev'));

// Routes
app.use('/api/v1/auth', require('./src/api/auth.routes'));
app.use('/api/v1/admin', require('./src/api/admin.routes'));
app.use('/api/v1/listings', require('./src/api/listing.routes'));
app.use('/api/v1', require('./src/api/lead.routes'));
app.use('/api/v1/valuation', require('./src/api/valuation.routes'));
app.use('/api/v1/payments', require('./src/api/payment.routes')); // New Route

const leadController = require('./src/controllers/lead.controller');
const { protect, authorize } = require('./src/middleware/auth.middleware');
app.post('/api/v1/leads', protect, authorize('buyer'), leadController.createLead);

// Sync DB & Start
db.sequelize.sync({ alter: true }).then(() => {
    console.log("‚úÖ Database Synced");
    
    // Initialize Cron Jobs
    initCronJobs();
    
    const PORT = process.env.PORT || 3000;
    app.listen(PORT, () => console.log(`üöÄ Server running on port ${PORT}`));
}).catch((err) => {
    console.error("‚ùå DB Error:", err.message);
});
</file>

<file path="package.json">
{
  "name": "biztech-buysell-backend",
  "version": "1.0.0",
  "main": "app.js",
  "scripts": {
    "dev": "nodemon app.js",
    "start": "node app.js"
  },
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "helmet": "^7.1.0",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.0",
    "mysql2": "^3.6.5",
    "node-cron": "^4.2.1",
    "sequelize": "^6.35.1"
  },
  "devDependencies": {
    "nodemon": "^3.0.2"
  }
}
</file>

<file path="src/api/admin.routes.js">
const express = require('express');
const router = express.Router();
const controller = require('../controllers/admin.controller');
const { protect, authorize } = require('../middleware/auth.middleware');

router.post('/create-agent', protect, authorize('admin'), controller.createAgent);
router.get('/pending-listings', protect, authorize('admin'), controller.getPendingListings);
router.post('/assign-agent', protect, authorize('admin'), controller.assignAgent);

module.exports = router;
</file>

<file path="src/api/auth.routes.js">
const express = require('express');
const router = express.Router();
const controller = require('../controllers/auth.controller');

router.post('/register', controller.register);
router.post('/login', controller.login);

module.exports = router;
</file>

<file path="src/api/lead.routes.js">
const express = require('express');
const router = express.Router();
const controller = require('../controllers/lead.controller');
const { protect, authorize } = require('../middleware/auth.middleware');

// Buyer creates lead
router.post('/', protect, authorize('buyer'), controller.createLead);

// Agent manages leads
router.get('/agent/leads', protect, authorize('agent'), controller.getAgentLeads); // Note: path modified in main app router to /api/v1/agent/leads
router.put('/agent/leads/:id', protect, authorize('agent'), controller.updateLeadStatus);

module.exports = router;
</file>

<file path="src/api/listing.routes.js">
const express = require('express');
const router = express.Router();
const controller = require('../controllers/listing.controller');
const { protect, authorize } = require('../middleware/auth.middleware');

router.post('/', protect, authorize('seller'), controller.createListing);
router.get('/', controller.getListings); // Public Search

// Optional middleware: If token exists, attach user, else continue as guest
router.get('/:id', async (req, res, next) => {
    if (req.headers.authorization) { await protect(req, res, next); } 
    else { next(); }
}, controller.getListingById);

router.post('/:id/financing', protect, authorize('seller'), controller.requestFinancing);

module.exports = router;
</file>

<file path="src/api/payment.routes.js">
const express = require('express');
const router = express.Router();
const controller = require('../controllers/payment.controller');
const { protect, authorize } = require('../middleware/auth.middleware');

// Debugging check (will print to console if undefined)
if (!controller.createSubscription) {
    console.error("‚ùå Error: controller.createSubscription is undefined in payment.routes.js");
}
if (!protect) {
    console.error("‚ùå Error: 'protect' middleware is undefined in payment.routes.js");
}

router.post('/subscribe', protect, authorize('seller'), controller.createSubscription);

module.exports = router;
</file>

<file path="src/api/valuation.routes.js">
const express = require('express');
const router = express.Router();
const controller = require('../controllers/valuation.controller');

router.post('/', controller.requestValuation);

module.exports = router;
</file>

<file path="src/config/database.js">
require('dotenv').config();

module.exports = {
  development: {
    username: process.env.DB_USER,
    password: process.env.DB_PASS,
    database: process.env.DB_NAME,
    host: process.env.DB_HOST,
    dialect: process.env.DB_DIALECT,
    logging: false
  },
  production: {
    username: process.env.DB_USER,
    password: process.env.DB_PASS,
    database: process.env.DB_NAME,
    host: process.env.DB_HOST,
    dialect: process.env.DB_DIALECT,
    logging: false
  }
};
</file>

<file path="src/controllers/admin.controller.js">
const db = require('../models');
const bcrypt = require('bcryptjs');
const User = db.User;
const Listing = db.Listing;

exports.createAgent = async (req, res) => {
    try {
        const { name, email, password } = req.body;
        const salt = await bcrypt.genSalt(10);
        const hashedPassword = await bcrypt.hash(password, salt);

        const user = await User.create({ 
            name, email, password: hashedPassword, role: 'agent' 
        });
        res.status(201).json({ success: true, data: { id: user.id, email: user.email } });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

exports.getPendingListings = async (req, res) => {
    try {
        const listings = await Listing.findAll({
            where: { status: 'pending' },
            include: [{ model: User, as: 'Seller', attributes: ['name', 'email'] }]
        });
        res.status(200).json({ success: true, count: listings.length, data: listings });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

exports.assignAgent = async (req, res) => {
    try {
        const { listingId, agentId } = req.body;
        
        const listing = await Listing.findByPk(listingId);
        if(!listing) return res.status(404).json({ message: "Listing not found" });

        const agent = await User.findOne({ where: { id: agentId, role: 'agent' } });
        if(!agent) return res.status(404).json({ message: "Agent not found" });

        await listing.update({
            assignedAgentId: agentId,
            status: 'active' // SRS: Status active upon assignment
        });

        res.status(200).json({ success: true, message: "Agent assigned, Listing Active", data: listing });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};
</file>

<file path="src/controllers/auth.controller.js">
const db = require('../models');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const User = db.User;

const generateToken = (id) => {
    return jwt.sign({ id }, process.env.JWT_SECRET, { expiresIn: '30d' });
};

exports.register = async (req, res) => {
    try {
        const { name, email, password, role, agreed_commission, financial_means } = req.body;

        // SRS Rule: Seller must agree to commission
        if (role === 'seller' && agreed_commission !== true) {
            return res.status(400).json({ message: "Sellers must agree to the 1% commission fee." });
        }

        // Security: Prevent creating admin/agent publicly
        if (role === 'admin' || role === 'agent') {
            return res.status(403).json({ message: "Restricted role creation." });
        }

        const userExists = await User.findOne({ where: { email } });
        if (userExists) return res.status(400).json({ message: "User already exists" });

        const salt = await bcrypt.genSalt(10);
        const hashedPassword = await bcrypt.hash(password, salt);

        const user = await User.create({
            name, email, password: hashedPassword, role, agreed_commission, financial_means
        });

        res.status(201).json({
            success: true,
            token: generateToken(user.id),
            user: { id: user.id, name: user.name, role: user.role }
        });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

exports.login = async (req, res) => {
    try {
        const { email, password } = req.body;
        const user = await User.findOne({ where: { email } });

        if (user && (await bcrypt.compare(password, user.password))) {
            res.json({
                success: true,
                token: generateToken(user.id),
                user: { id: user.id, name: user.name, role: user.role }
            });
        } else {
            res.status(401).json({ message: "Invalid credentials" });
        }
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};
</file>

<file path="src/controllers/lead.controller.js">
const db = require('../models');
const Lead = db.Lead;
const Listing = db.Listing;
const User = db.User;

exports.createLead = async (req, res) => {
    try {
        const { listingId, message } = req.body;
        
        const listing = await Listing.findByPk(listingId);
        if (!listing) return res.status(404).json({ message: "Listing not found" });

        const lead = await Lead.create({
            listingId,
            buyerId: req.user.id,
            message
        });

        res.status(201).json({ success: true, data: lead });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

exports.getAgentLeads = async (req, res) => {
    try {
        // Find leads for listings assigned to this agent
        const leads = await Lead.findAll({
            include: [
                { 
                    model: Listing, 
                    as: 'Listing', 
                    where: { assignedAgentId: req.user.id },
                    attributes: ['title', 'id']
                },
                {
                    model: User,
                    as: 'Buyer',
                    attributes: ['name', 'email', 'financial_means']
                }
            ]
        });

        res.status(200).json({ success: true, count: leads.length, data: leads });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

exports.updateLeadStatus = async (req, res) => {
    try {
        const lead = await Lead.findByPk(req.params.id, {
            include: [{ model: Listing, as: 'Listing' }]
        });
        
        if (!lead) return res.status(404).json({ message: "Lead not found" });

        // Authorization check: Only assigned agent
        if (lead.Listing.assignedAgentId !== req.user.id) {
            return res.status(403).json({ message: "Not authorized" });
        }

        await lead.update({ status: req.body.status });
        res.status(200).json({ success: true, data: lead });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};
</file>

<file path="src/controllers/listing.controller.js">
const db = require('../models');
const { Op } = require('sequelize');
const Listing = db.Listing;
const User = db.User;

exports.createListing = async (req, res) => {
    try {
        const { 
            title, industry, price, net_profit, turnover, region, 
            legal_business_name, full_address, owner_name, tier 
        } = req.body;

        const listing = await Listing.create({
            sellerId: req.user.id,
            title, industry, price, net_profit, turnover, region,
            legal_business_name, full_address, owner_name,
            tier: tier || 'basic',
            status: 'pending'
        });

        res.status(201).json({ success: true, data: listing });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

exports.getListings = async (req, res) => {
    try {
        const { location, priceMax, industry } = req.query;
        let whereClause = { status: 'active' };

        if (location) whereClause.region = { [Op.like]: `%${location}%` };
        if (industry) whereClause.industry = { [Op.like]: `%${industry}%` };
        if (priceMax) whereClause.price = { [Op.lte]: priceMax };

        const listings = await Listing.findAll({
            where: whereClause,
            order: [
                ['tier', 'DESC'], // Premium first (DESC because 'premium' > 'basic' alphabetically? No, check enum order or map it)
                // Actually 'premium' > 'basic' string wise works, or use custom logic. 
                // Better approach:
                [db.sequelize.literal("FIELD(tier, 'premium', 'basic')"), 'ASC'],
                ['createdAt', 'DESC']
            ],
            attributes: { exclude: ['legal_business_name', 'full_address', 'owner_name'] } // Masking Private Data
        });

        res.status(200).json({ success: true, count: listings.length, data: listings });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

exports.getListingById = async (req, res) => {
    try {
        const listing = await Listing.findByPk(req.params.id);
        if (!listing) return res.status(404).json({ message: "Listing not found" });

        // Logic for Data Masking (NFR-SE-001)
        let isAuthorized = false;
        
        if (req.user) {
            if (req.user.role === 'admin') isAuthorized = true;
            if (req.user.role === 'seller' && listing.sellerId === req.user.id) isAuthorized = true;
            if (req.user.role === 'agent' && listing.assignedAgentId === req.user.id) isAuthorized = true;
        }

        let response = listing.toJSON();

        if (!isAuthorized) {
            // Mask Private Data
            delete response.legal_business_name;
            delete response.full_address;
            delete response.owner_name;
            
            // Increment view count
            await listing.increment('views');
        }

        res.status(200).json({ success: true, data: response });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

exports.requestFinancing = async (req, res) => {
    try {
        const listing = await Listing.findByPk(req.params.id);
        if(!listing) return res.status(404).json({ message: "Listing not found" });

        if (listing.sellerId !== req.user.id) return res.status(403).json({ message: "Unauthorized" });
        if (listing.tier !== 'premium') return res.status(400).json({ message: "Only Premium sellers can request financing" });

        await listing.update({ financing_requested: true });
        res.status(200).json({ success: true, message: "Financing request sent to agent" });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};
</file>

<file path="src/controllers/payment.controller.js">
const db = require('../models');
const Subscription = db.Subscription;
const Listing = db.Listing;

// @desc    Simulate Payment for Premium Listing
// @route   POST /api/v1/payments/subscribe
exports.createSubscription = async (req, res) => {
    try {
        const { listingId, amount } = req.body; 

        // Check if listing exists
        const listing = await Listing.findByPk(listingId);
        if (!listing) {
            return res.status(404).json({ message: "Listing not found" });
        }

        // 1. Create Subscription Record
        // (Ensure Subscription model exists in src/models/Subscription.js)
        const subscription = await Subscription.create({
            userId: req.user.id,
            listingId: listing.id,
            amount: amount,
            payment_status: 'paid', // Mocking successful payment
            transaction_id: `tx_${Date.now()}`,
            start_date: new Date(),
            end_date: new Date(new Date().setDate(new Date().getDate() + 90)) // +90 Days
        });

        // 2. Update Listing to Premium & Active
        await listing.update({
            tier: 'premium',
            status: 'active',
            expiryDate: subscription.end_date
        });

        res.status(201).json({ 
            success: true, 
            message: "Subscription successful. Listing upgraded to Premium.",
            data: subscription 
        });

    } catch (error) {
        console.error("Payment Error:", error);
        res.status(500).json({ message: error.message });
    }
};
</file>

<file path="src/controllers/valuation.controller.js">
const db = require('../models');
const Valuation = db.Valuation;

exports.requestValuation = async (req, res) => {
    try {
        const { contactName, contactEmail, phone, businessDetails } = req.body;
        
        // Save to Database
        const valuation = await Valuation.create({
            contact_name: contactName || "Anonymous", // Handle optional fields
            contact_email: contactEmail,
            phone: phone,
            business_details: businessDetails
        });

        res.status(201).json({ 
            success: true, 
            message: "Valuation request saved successfully.",
            data: valuation
        });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};
</file>

<file path="src/middleware/auth.middleware.js">
const jwt = require('jsonwebtoken');
const db = require('../models');
const User = db.User;

exports.protect = async (req, res, next) => {
    let token;
    if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
        try {
            token = req.headers.authorization.split(' ')[1];
            const decoded = jwt.verify(token, process.env.JWT_SECRET);
            req.user = await User.findByPk(decoded.id);
            if(!req.user) throw new Error("User not found");
            next();
        } catch (error) {
            res.status(401).json({ message: "Not authorized, token failed" });
        }
    } else {
        res.status(401).json({ message: "Not authorized, no token" });
    }
};

exports.authorize = (...roles) => {
    return (req, res, next) => {
        if (!req.user) return res.status(401).json({ message: "User not authenticated" });
        if (!roles.includes(req.user.role)) {
            return res.status(403).json({ message: `Role ${req.user.role} is not authorized` });
        }
        next();
    };
};
</file>

<file path="src/models/index.js">
const Sequelize = require('sequelize');
const config = require('../config/database')[process.env.NODE_ENV || 'development'];

const sequelize = new Sequelize(config.database, config.username, config.password, config);

const db = {};
db.Sequelize = Sequelize;
db.sequelize = sequelize;

// Import Models
db.User = require('./User')(sequelize, Sequelize);
db.Listing = require('./Listing')(sequelize, Sequelize);
db.Lead = require('./Lead')(sequelize, Sequelize);
// --- NEW MODELS ---
db.Subscription = require('./Subscription')(sequelize, Sequelize);
db.Valuation = require('./Valuation')(sequelize, Sequelize);

// Initialize associations
Object.keys(db).forEach(modelName => {
    if (db[modelName].associate) {
        db[modelName].associate(db);
    }
});

module.exports = db;
</file>

<file path="src/models/Lead.js">
module.exports = (sequelize, DataTypes) => {
    const Lead = sequelize.define("Lead", {
        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
        message: { type: DataTypes.TEXT, allowNull: false },
        status: { 
            type: DataTypes.ENUM('new', 'contacted', 'closed'), 
            defaultValue: 'new' 
        }
    });

    Lead.associate = (models) => {
        Lead.belongsTo(models.Listing, { foreignKey: 'listingId', as: 'Listing' });
        Lead.belongsTo(models.User, { foreignKey: 'buyerId', as: 'Buyer' });
    };

    return Lead;
};
</file>

<file path="src/models/Listing.js">
module.exports = (sequelize, DataTypes) => {
    const Listing = sequelize.define("Listing", {
        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
        // Public Data
        title: { type: DataTypes.STRING, allowNull: false },
        industry: { type: DataTypes.STRING, allowNull: false },
        region: { type: DataTypes.STRING, allowNull: false },
        price: { type: DataTypes.DECIMAL(15, 2), allowNull: false },
        net_profit: { type: DataTypes.DECIMAL(15, 2) },
        turnover: { type: DataTypes.DECIMAL(15, 2) },
        
        // Private Data (Masked)
        legal_business_name: { type: DataTypes.STRING },
        full_address: { type: DataTypes.TEXT },
        owner_name: { type: DataTypes.STRING },

        // Meta
        tier: { 
            type: DataTypes.ENUM('basic', 'premium'), 
            defaultValue: 'basic' 
        },
        status: { 
            type: DataTypes.ENUM('pending', 'active', 'sold', 'expired'), 
            defaultValue: 'pending' 
        },
        expiryDate: { type: DataTypes.DATE },
        views: { type: DataTypes.INTEGER, defaultValue: 0 },
        financing_requested: { type: DataTypes.BOOLEAN, defaultValue: false }
    });

    Listing.associate = (models) => {
        Listing.belongsTo(models.User, { foreignKey: 'sellerId', as: 'Seller' });
        Listing.belongsTo(models.User, { foreignKey: 'assignedAgentId', as: 'Agent' });
        Listing.hasMany(models.Lead, { foreignKey: 'listingId', as: 'Leads' });
    };

    return Listing;
};
</file>

<file path="src/models/Subscription.js">
module.exports = (sequelize, DataTypes) => {
    const Subscription = sequelize.define("Subscription", {
        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
        amount: { type: DataTypes.DECIMAL(10, 2), allowNull: false },
        currency: { type: DataTypes.STRING, defaultValue: 'AED' },
        payment_status: { 
            type: DataTypes.ENUM('pending', 'paid', 'failed'), 
            defaultValue: 'pending' 
        },
        transaction_id: { type: DataTypes.STRING }, // From Stripe/Gateway
        start_date: { type: DataTypes.DATE },
        end_date: { type: DataTypes.DATE }
    });

    Subscription.associate = (models) => {
        Subscription.belongsTo(models.User, { foreignKey: 'userId', as: 'User' });
        Subscription.belongsTo(models.Listing, { foreignKey: 'listingId', as: 'Listing' });
    };

    return Subscription;
};
</file>

<file path="src/models/User.js">
module.exports = (sequelize, DataTypes) => {
    const User = sequelize.define("User", {
        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
        name: { type: DataTypes.STRING, allowNull: false },
        email: { type: DataTypes.STRING, allowNull: false, unique: true, validate: { isEmail: true } },
        password: { type: DataTypes.STRING, allowNull: false },
        role: { 
            type: DataTypes.ENUM('admin', 'agent', 'seller', 'buyer'), 
            defaultValue: 'buyer' 
        },
        mobile: { type: DataTypes.STRING },
        // Buyer Specific
        financial_means: { 
            type: DataTypes.ENUM('<100k', '100k-1M', '>1M'),
            allowNull: true
        },
        // Seller Specific
        agreed_commission: { 
            type: DataTypes.BOOLEAN, 
            defaultValue: false 
        }
    });

    User.associate = (models) => {
        User.hasMany(models.Listing, { foreignKey: 'sellerId', as: 'Listings' });
        User.hasMany(models.Listing, { foreignKey: 'assignedAgentId', as: 'AssignedListings' });
        User.hasMany(models.Lead, { foreignKey: 'buyerId', as: 'Enquiries' });
    };

    return User;
};
</file>

<file path="src/models/Valuation.js">
module.exports = (sequelize, DataTypes) => {
    const Valuation = sequelize.define("Valuation", {
        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
        contact_name: { type: DataTypes.STRING, allowNull: false },
        contact_email: { type: DataTypes.STRING, allowNull: false, validate: { isEmail: true } },
        phone: { type: DataTypes.STRING },
        business_details: { type: DataTypes.TEXT, allowNull: false },
        status: { 
            type: DataTypes.ENUM('new', 'reviewed', 'contacted'), 
            defaultValue: 'new' 
        }
    });

    return Valuation;
};
</file>

<file path="src/services/cron.service.js">
const cron = require('node-cron');
const { Op } = require('sequelize');
const db = require('../models');
const Listing = db.Listing;
const { sendEmail } = require('./email.service');

const initCronJobs = () => {
    // Run every day at midnight: '0 0 * * *'
    cron.schedule('0 0 * * *', async () => {
        console.log('--- Running Daily Listing Expiry Check ---');
        try {
            const today = new Date();
            
            // Find active premium listings that have expired
            const expiredListings = await Listing.findAll({
                where: {
                    status: 'active',
                    expiryDate: { [Op.lt]: today }, // Less than today
                    tier: 'premium'
                },
                include: ['Seller']
            });

            for (const listing of expiredListings) {
                // Update status
                listing.status = 'expired';
                await listing.save();

                // Notify Seller
                if (listing.Seller && listing.Seller.email) {
                    await sendEmail(
                        listing.Seller.email, 
                        "Your Listing Has Expired", 
                        `Your listing "${listing.title}" has expired. Please renew your subscription.`
                    );
                }
            }
            console.log(`Processed ${expiredListings.length} expired listings.`);
        } catch (error) {
            console.error('Cron Job Error:', error);
        }
    });
};

module.exports = initCronJobs;
</file>

<file path="src/services/email.service.js">
// In production, use 'nodemailer' or 'sendgrid'
exports.sendEmail = async (to, subject, text) => {
    console.log(`[EMAIL SERVICE] Sending to: ${to}`);
    console.log(`Subject: ${subject}`);
    console.log(`Body: ${text}`);
    return true;
};
</file>

</files>
